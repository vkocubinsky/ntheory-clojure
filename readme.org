#+title: Number theory with Clojure
#+startup: nolatexpreview
#+PROPERTY: header-args:clojure :session *clojure-1* :cache yes :exports both :results pp

* About

This project cover some topics in number theory, especially arithmetic
functions, further more multiplicative functions. There are set of
well known arithmetic functions and one can define custom arithmetic
functions.

I wrote this document with Emacs Org Mode. Then I generated markdown
file with Org Mode export to markdown =C-c C-e m m= to show it nicely
on github. I use Emacs babel to produce real output inside the
document.

In this document I load number theory package as: 

#+begin_src clojure :results silent
  (require '[vk.ntheory :as nt])
  (require '[clojure.math :as math])
#+end_src

So below I will use ~nt~ alias.

* Notation

- $\mathbf N$ - Natural numbers, positive integers $1,2,3,\dots$
- $\mathbf C$ - Complex numbers
- $\mathbf Z$ - Integers $\dots -3, -2, -1, 0, 1, 2, 3, \dots$

* Performance and cache

This library is designed to work with realtive small integers. Library
keep in cache least prime divisor table for fast integer
factorization.  Cache grows automatically. The strategy of growing is
extends cache to the least power of ~10~ more than required
number. For instance, if client asked to factorize number ~18~, cache
grows to ~100~, if client asked to factorize number ~343~, cache grows
to ~1000~. List of primes also cached and recalculated together
with least prime divisor table. Recalculation is not incremental, but
every recalculation of least prime divisor table make a table which is
in ~10~ times more than previous, and time for previous calculation is
~10~ times less than for new one. So we can say that recalculation
spent almost all time for recalculate latest least prime divisor
table.

Internally, least prime divisor table is java array of int, so to store
least divisor table for first ~1 000 000~ number approximately ~4M~
memory is required, ~4~ bytes per number.

Cache can be reset:

#+begin_src clojure
  (nt/ldt-reset!)
#+end_src

#+RESULTS[cfa53206fc7267849381fd5f79c6df8d156608c0]:
: {:least-divisor-table , :primes , :upper 0}
: 

Least prime divisor table is implementation details, but one can see
it:

#+begin_src clojure
  (nt/integer->factors-map 5); load first 10 natural numbers
  @ldt
#+end_src

#+RESULTS[a41225de7dd2af0bb687d53e85df64dd53aa7a13]:
: {:least-divisor-table [0, 1, 2, 3, 2, 5, 2, 7, 2, 3, 2],
:  :primes (2 3 5 7),
:  :upper 10}
: 

For instance, for get least prime divisor of number 6 we need to get
element with index 6, which is 2. Index zero is not used, value for
index 1 is 1.

* Prime numbers

~primes~ function returns prime numbers which not exceeds given ~n~.

#+begin_src clojure
(nt/primes 30)
#+end_src

#+RESULTS[763796e7ffa04546417c55a7b12dc1b756c02534]:
: (2 3 5 7 11 13 17 19 23 29)
: 


* Integer factorization

Every integer more than $1$ can be represented uniquely as a product
of primes.


\[
n = {p_1}^{a_1} {p_2}^{a_2} \dots {p_k}^{a_k}
\]

or we can write it in more compact form:

\[
n = \prod_{i=1}^{k} {p_i}^{a_i}
\]

or even write as:

$$n = \prod_{p|n} p^a$$


If we accept that empty product is $1$ we can say that every natural
number can be represent uniquely as a product of primes. For example
$360 = 2^3 3^2 5^1$.

There are some functions to factorize integers. Each of them accept
natural number as an argument and returns factorized value. It have
slightly different output, which may be more appropriate to different
use cases. For each factorize function there is also inverse function,
which accept factorized value and convert it back to integer.

1-st factorization representation is ordered sequence of primes:

#+begin_src clojure
  (nt/integer->factors 360)
#+end_src

#+RESULTS[6822178aec96d1cfeeb597af7d3633fede07b2eb]:
: (2 2 2 3 3 5)
: 
  
#+begin_src clojure
  (nt/factors->integer [2 2 2 3 3 5])
#+end_src

#+RESULTS[be5dc481f46fd3b607346dd9644742d71b4f7556]:
: 360
: 

2-nd factorization representation is ordered sequence of primes
splited by partitions by a prime:

#+begin_src clojure
  (nt/integer->factors-partitions 360)
#+end_src

#+RESULTS[7e4f4eada98811a1359eddac44c8a0bb5f66cdff]:
: ((2 2 2) (3 3) (5))
: 
  
#+begin_src clojure
  (nt/factors-partitions->integer [[2 2 2] [3 3] [5]])
#+end_src

#+RESULTS[4f3000a8f01bb3bffb6f1c145bbbc4cfd9e42c16]:
: 360
: 

3-rd factorization representation is ordered sequence of pairs ~[p
k]~, where ~p~ is a prime and ~k~ is a power of prime

#+begin_src clojure
  (nt/integer->factors-count 360)
#+end_src

#+RESULTS[deb84c857b6e7c95f8cf1bed52b147f3757c98ea]:
: ([2 3] [3 2] [5 1])
: 
  
#+begin_src clojure
  (nt/factors-count->integer [[2 3] [3 2] [5 1]])
#+end_src

#+RESULTS[337833a77e534d69e5bd1a2655a79412e0a99bd3]:
: 360
: 

4-th factorization representation is very similar to 3-rd, but it
is a map. And it has the same inverse function as 3-rd.

#+begin_src clojure
  (nt/integer->factors-map 360)
#+end_src

#+RESULTS[6f56766d178fd644b1e6dd9d5c530dc3c936abc7]:
: {2 3, 3 2, 5 1}
: 

#+begin_src clojure
  (nt/factors-count->integer {2 3, 3 2, 5 1})
#+end_src

#+RESULTS[85c61af8e9717c094e6d06e3abbbbbc1303673e6]:
: 360
: 

Implementation of factorization use least prime divisor table. To
factorize number ~n~ it is enough to calculate least divisor table
with size less or equals to $\sqrt n$. 

* Divisors

For get list of all divisors of number ~n~ there is ~divisor~
function. List of divisors is unordered.

#+begin_src clojure
  (nt/divisors 30)
#+end_src

#+RESULTS[eb92a166694fca9e52907ba5cc3800b132e83a1f]:
: (1 2 3 6 5 10 15 30)
: 

* Arithmetical functions

Arithmetical function is an any function which accept natural number
and return complex number $f: \mathbf N \to \mathbf C$. The library mostly works
with functions which also returns integer $f: \mathbf N \to \mathbf Z$.

* Function equality

Two arithmetical function $f$ and $g$ are equal if $f(n)=g(n)$ for all
natual $n$. There is helper function ~f-equlas~ which compare two
functions on some sequence of natual numbers. Function ~f-equals~
accept two functions and optionally sequence of natural numbers. There
is a default for sequence of natural numbers, it is a variable
~default-natural-sample~, which is currently ~range(1,100)~.

If we like identify does two function ~f~ and ~g~ equals on some
sequence of natural number we can for example do next:

#+begin_src clojure :results silent
  ;; Let we have some f and g
  (def f identity)
  (def g (constantly 1))
  ;; Then we able to check does those functions are equals
  (nt/f-equals f g)
  (nt/f-equals f g (range 1 1000))
  (nt/f-equals f g (filter even? (range 1 100)))
#+end_src

* Additive functions

Additive function is a function for which

$$ f(mn) = f(m) + f(n)$$

if $m$ relatively prime to $n$. If above equality holds for all
natural $m$ and $n$ function called completely additive.

To define an additive function it is enough to define how to
calculate a function on power of primes.
If $n = p_1^{a_1} p_2^{a_2} \dots p_k^{a_k}$ then: 

$$ f(n) = \sum_{i=1}^{k} f({p_i}^{a_i}) $$

* Multiplicative functions

Multiplicative function is a function not equal to zero for all n
for which 

$$ f(mn) = f(m)f(n) $$

if $m$ relatively prime to $n$. If above equality holds for all
natural $m$ and $n$ function called completely multiplicative.

To define multiplicative function it is enough to define how to
calculate a function on power of primes. If $n = p_1^{a_1} p_2^{a_2}
\dots p_k^{a_k}$ then:

$$ f(n) = \prod_{i=1}^{k} f({p_i}^{a_i}) $$

* Higher order function for define multiplicative and additive functions

As we have seen, to define either multiplicative or additive function
it is enough define function on power of a prime.  There is helper
function ~reduce-on-prime-count~ which provide a way to define a
function on power of a prime. The first parameter of
~reduce-on-prime-count~ is reduce function which usually ~*~ for
multiplicative function and usually ~+~ for additive function, but
custom reduce function also acceptable.

For instance, we can define function which calculate number of
divisors of integer ~n~. If $n = p_1^{a_1} p_2^{a_2} \dots p_k^{a_k}$ count of divisors of
number ~n~ can be calculated by formula:

$$ \sigma_0(n) = \prod_{i=1}^{k} (a_i + 1) $$

With helper function it can be defined as

#+begin_src clojure
  (def my-divisors-count
  (nt/reduce-on-prime-count * (fn [p k] (inc k))))
  (my-divisors-count 6)
#+end_src

#+RESULTS[70b9288870478d799579fafdb999ad04378c2803]:
: 4
: 

Of course there is predefined function ~divisors-count~, but it
is an example how to define custom function.

* Some additive functions

** Count of distinct primes - $\omega$

Count of distinct primes is a number of distinct primes which
divides given $n$. If $n = p_1^{a_1} p_2^{a_2} \dots p_k^{a_k}$ then $\omega = k$.

#+begin_src clojure
   (nt/primes-count-distinct (* 2 2 3))
#+end_src

#+RESULTS[3552f94a82caf8b47add374a87b582087b94f377]:
: 2
: 

** Total count of primes - $\Omega$

Total count of primes is a number of primes and power of primes
which divides $n$. If $n = p_1^{a_1} p_2^{a_2} \dots p_k^{a_k}$ then:

$$\Omega = a_1 + a_2 + \dots + a_k$$

#+begin_src clojure
  (nt/primes-count-total (* 2 2 3))
#+end_src

#+RESULTS[51c9f0f12a6224d26735728783dec13755a0633e]:
: 3
: 

* Some multiplicative functions

** Mobius function - $\mu$.

Mobius function defined as:


$$ \mu(n) = \begin{cases}
1        &  \quad \text{if } n = 1 \\
(-1)^k   &  \quad \text{if } n \text{ product of distinct primes} \\
0        &  \quad \text{otherwise}
\end{cases} $$

For example, $\mu(6)=\mu(2 \cdot 3)=1$

#+begin_src clojure
  (nt/mobius 6)
#+end_src

#+RESULTS[cf4859295d68505bb9cd0db612b385de1ebf5376]:
: 1
: 


** Euler totient function - $\phi$

Euler totient function  is a count of numbers relative  prime to given
number ~n~.  Totient function can be calculated by formula:


$$ \phi(n) = \prod_{p|n} (p^a - p^{a-1}) $$

For example, count of numbers relative prime to $6$ are $1$ and $5$, so $\phi(6) = 2$

#+begin_src clojure
  (nt/totient 6)
#+end_src

#+RESULTS[c7763e09447503d128331d4f95f7799db7bd4679]:
: 2
: 

** Unit function - $\epsilon$

Unit function defined as

$$ \epsilon(n) = \begin{cases}
1,&  \text{if } n = 1 \\
0,&  \text{if } n > 1
\end{cases} $$

#+begin_src clojure
  (nt/unit 6)
#+end_src

#+RESULTS[fe946ead0f672382244e7788ffc0800baecdad98]:
: 0
: 

** Constant one function - $1$

$$ 1(n) = 1 $$

#+begin_src clojure
  (nt/one 6)
#+end_src

#+RESULTS[a9b4f951368a936801ef98b7badd4dc39dea886f]:
: 1
: 


** Divisors count - $\sigma_0$

Divisors count is number of divisors which divides given number $n$.

$$ \sigma_0(n) = \sum_{d|n} 1 $$

For example, number $64$ has $4$ divisors, namely $1,2,3,6$, so $\sigma_0(6)=4$

#+begin_src clojure
  (nt/divisors-count 6)
#+end_src

#+RESULTS[decfebfc920e6b3c30105d4e96db3a33f2f50e35]:
: 4
: 

** Divisors sum - $\sigma_1$


$$ \sigma_1(n) = \sum_{d | n} d $$

For number 6 it is $12 = 1 + 2 + 3 + 6$

#+begin_src clojure
  (nt/divisors-sum 6)
#+end_src

#+RESULTS[937569fa024eae6602b07f07b2c3b364ac62cf0c]:
: 12
: 

** Divisors square sum

$$ \sigma_2(n) = \sum_{d | n} d^2 $$

For number 6 it is $50 = 1^2 + 2^2 + 3^2 + 6^2$

#+begin_src clojure
  (nt/divisors-square-sum 6)
#+end_src

#+RESULTS[e37fb8014bf18bca9cc23b39e26bb461bc7ce6d6]:
: 50
: 

** Divisors higher order function - $\sigma_{x}$

In general $\sigma_x$ function is a sum of x-th powers divisors of given n

$$ \sigma_x(n) = \sum_{ d | n} d^x $$

If $x \ne 0$ $\sigma_x$ can be calculated by formula:

$$ \sigma_{x}(n) = \prod_{i=1}^{k} \frac {p_i^{(a_i+1)x}} {p_i^x - 1} $$

and if $x = 0$ by formula:

$$ \sigma_{0}(n) = \prod_{i=1}^{k} (a_i + 1) $$

There is higher order function ~divisors-sum-x~ which
accept ~x~ and return appropriate function.

#+begin_src clojure :results silent
  (def my-divisors-square-sum (nt/divisors-sum-x 2))
#+end_src

** Liouville - $\lambda$

Liouville function can be defind by formula:

$$\lambda(n) = (-1)^{\Omega(n)}$$

where [[*Total count of primes - $\Omega$][$\Omega$]] have been descibed above.

#+begin_src clojure
  (nt/liouville (* 2 3)) 
#+end_src

#+RESULTS[869850b293d2a60abef6a5639489018149613db4]:
: 1
: 

* Some other arithmetic functions

** Mangoldt - $\Lambda$

$$\Lambda(n) = \begin{cases}
   \log p,& \text{if $n$ is power of prime i.e. $n = p^k$} \\
   0,& \text{otherwise} 
\end{cases}$$

For example $\Lambda(8) = \log 2$, $\Lambda(6) = 0$  

#+begin_src clojure
  (nt/mangoldt 2)
#+end_src

#+RESULTS[542691e004afaeca227b31c85287fa1086ef1c7a]:
: 0.6931471805599453
: 
  
#+begin_src clojure
  (nt/mangoldt 6)
#+end_src

#+RESULTS[c45312e6447f258aca43ab10d232e6e8c943b095]:
: 0
: 


** Chebyshev functions $\theta$ and $\psi$

There are two Chebyshev functions, one $\theta$ is defined as

$$\theta(x) = \sum_{p \le x} \log p$$

second $\psi$ defined as

$$\psi = \sum_{n \le x} {\Lambda(n)} $$

where [[*Mangoldt - $\Lambda$][$\Lambda$]] have been described above


#+begin_src clojure
  (nt/chebyshev-first 2)
#+end_src

#+RESULTS[cebd13d9e26c3ad5f4dffa6d9b3318e352ecaf8b]:
: 0.6931471805599453
: 
  
#+begin_src clojure
  (nt/chebyshev-second 2)
#+end_src

#+RESULTS[2a19f1e0aa91c0b965be5aee1939f687592600b2]:
: 0.6931471805599453
: 

* Dirichlet convolution

For two arithmetic functions $f$ and $g$ Dirichlet convolution is a
new arithmetic function defined as

$$ (f*g)(n) = \sum_{d | n} f(d)g(\frac{n}{d}) $$

Dirichlet convolution is associative

$$ (f * g) * h = f * (g * h) $$

Commutative

$$ f * g = g * f $$

Has identify

$$ f * \epsilon = \epsilon * f = f $$

For every $f$, which $f(1) \ne 0$ exists inverse function $f^{-1}$
such that $f * f^{-1} = \epsilon$. This inverse function called
Dirichlet inverse and can by calculated recursively by formula:

$$ f^{-1}(n) = \begin{cases}
\frac{1}{f(1)} & \quad \text{if } n = 1  \\
\frac{-1}{f(1)}\sum_{ \substack{d | n\\
                                d < n}} f(\frac{n}{d}) f^{-1}(d)
               & \quad n \ge 1
\end{cases} $$


For example, $1(n) * 1(n) = \sigma_0$

#+begin_src clojure
  (nt/f-equals
     (nt/dirichlet-convolution nt/one nt/one)
     nt/divisors-count
  )
#+end_src

#+RESULTS[57087c9ba65232b20217853c2e785c62527b3666]:
: true
: 

Dirichlet convolution is associative so clojure method support more than two
function as parameter of ~f*~

#+begin_src clojure
  (nt/f-equals
    (nt/dirichlet-convolution nt/mobius nt/one nt/mobius nt/one)
    nt/unit
  )
#+end_src

#+RESULTS[13fd6000aaba4122437535d8be6a4d8841038ace]:
: true
: 

Another example, functions $\mu(n)$ and $1(n)$ are inverse of each other

#+begin_src clojure
  (nt/f-equals (nt/dirichlet-inverse nt/one) nt/mobius)
#+end_src

#+RESULTS[33bbf9139c179db71af6a5d185b937afad79f0f6]:
: true
: 
  
#+begin_src clojure
  (nt/f-equals (nt/dirichlet-inverse nt/mobius) nt/one)
#+end_src

#+RESULTS[e17afcfeaabbc9d50d6f000814f6e2e43b7f447e]:
: true
: 



