#+title: Number theory with Clojure
#+startup: nolatexpreview

* About

Number theory with Clojure. This project cover some topics in number
theory, especially arithmetic functions, further more multiplicative
functions. There are set of well known multiplicative functions and
one can define custom multiplicative functions.

I wrote this document with Emacs Org Mode. Then I generated markdown
file to show it nicely on github. I use Emacs babel to produce real
output inside the document.

In this document I load number theory package as: 

#+begin_src clojure :results silent
  (require '[vk.ntheory :as nt])
#+end_src

So below I will use ~nt~ alias.

* Notation

$\mathbf N$ - Natural numbers, positive integers $1,2,3,\dots$

$\mathbf C$ - Complex numbers
$\mathbf Z$ - Integers $\dots -3, -2, -1, 0, 1, 2, 3, \dots$

If $n \in \mathbf N$ there is canonical representation of $n$ 
$$
\[
n = {p_1}^{a_1} {p_2}^{a_2} \dots {p_k}^{a_k} = \prod_{i=1}^{k} {p_i}^{a_i} = \prod_{p | n} {p^a}
\]
$$

* Performance and cache

This library is designed to work with realtive small integers. Library
keep in cache least divisor table for fast integer factorization.
Cache grows automatically. The strategy of growing is round required
number to the nearest power of ~10~. For instance, if client asked to
factorize number ~18~, cache grows to ~100~, if client asked to factorize
number ~343~, cache grows to ~1000~, etc. List of primes also cached and
recalculated together with least divisor table. Recalculation is not
incremental, but every recalculation of least divisor table make a
table which is in ~10~ times more than previous, and time for previous
calculation is ~10~ times less than for new one. So we can say that the
library spent almost all time for latest least divisor table.

Internally, least divisor table is java array of int, so to store
least divisor table for first ~10 000 000~ number approximately ~40M~
memory is required, ~4~ bytes per number.

To free memory cache can be reset

#+begin_src clojure :results pp :exports both
  (nt/ldt-reset!)
#+end_src

#+RESULTS:
: {:least-divisor-table , :primes , :upper 0}
: 

Least divisor table is implementation details, but one can see it

#+begin_src clojure :results pp :exports both
  (nt/ldt-factorize 5); load first 10
  @ldt

#+end_src

#+RESULTS:
: {:least-divisor-table [0, 1, 2, 3, 2, 5, 2, 7, 2, 3, 2],
:  :primes (2 3 5 7),
:  :upper 10}
: 

* Prime numbers

There is ~primes~ functions which returns prime numbers which not
exceeds given ~n~.

#+begin_src clojure :results pp :exports both
(nt/primes 30)
#+end_src

#+RESULTS:
: (2 3 5 7 11 13 17 19 23 29)
: 

* Integer factorization

Every integer more than $1$ can be represented uniquely as a product
of primes.

\[
n = {p_1}^{a_1} {p_2}^{a_2} \dots {p_k}^{a_k} = \prod_{i=1}^{k} {p_i}^{a_i}
\]

If we accept that empty product is $1$ we can say that every natural
numbers can be represent uniquely as a product of primes. For example
$360 = 2^3 3^2 5^1$.

There is a function ~factorize~ which return factorization for given
~n~.  The result is a map for which key is a prime number and
value is an order of prime in ~n~.

#+begin_src clojure :results pp :exports both
  (nt/factorize 360)
#+end_src

#+RESULTS:
: {2 3, 3 2, 5 1}
: 

There is also inverse function of ~factorize~ which accept prime
factorization and return integer.

#+begin_src clojure :results pp :exports both
  (nt/de-factorize {2 3, 3 2, 5 1})
#+end_src

#+RESULTS:
: 360
: 

Implementation of ~factorize~ function use least divisor table. To
factorize number ~n~ it is enough to calculate least divisor table
with size less or equals to $\sqrt n$. 

* Divisors

For get list of all divisors of number ~n~ there is ~divisor~
function. List of divisors is unordered.

#+begin_src clojure :results pp :exports both
  (nt/divisors 30)
#+end_src

#+RESULTS:
: (1 2 3 6 5 10 15 30)
: 

* Arithmetical functions

Arithmetical function is an any function which accept natural number
and return complex number $f: \mathbf N \to \mathbf C$. I mainly works
with functions which also returns integer $f: \mathbf N \to \mathbf Z$.

* Function equality

Two arithmetical function $f$ and $g$ are equal if $f(n)=g(n)$ for all
natual $n$. There is helper function ~f=~ which compare two
functions on some subset of natual numbers. Function ~f=~ accept
two functions and subset of natural numbers. There is a default for
subset of natural numbers, currently it is ~range(1,100)~.

If we like identify does two function ~f~ and ~g~ equals on some
subset of natural number we can for example do next:

#+begin_src clojure :results silent
  (nt/f= f g)
  (nt/f= f g (range 1 1000))
  (nt/f= f g (filter even? (range 1 100)))
#+end_src


* Multiplicative functions

Important class of arithmetical functions consists multiplicative functions.
Multiplicative function is a function for which 

$$ f(mn) = f(m)f(n) \quad \text{if } m \text{ relatively prime to } n $$

To define multiplicative function it is enough to define how to
calculate a function on power of primes.

$$ f(n) = \prod_{i=1}^{k} f({p_i}^{a_i}) $$

There is higher order functions ~multiplicative-function~ which accept
function to calculate multiplicative function on power of primes and
return function defined for all natural numbers.

For instance, we can define function which calculate number of
divisors of integer ~n~. Count of divisors of number ~n~ can be
calculated by formula

$$ \sigma_0(n) = \prod_{i=1}^{k} (a_i + 1) $$

#+begin_src clojure :results silent 
  (def my-divisors-count
  (nt/multiplicative-function (fn [p k] (inc k))))
#+end_src

#+begin_src clojure :results pp :exports both
  (my-divisors-count 6)
#+end_src

#+RESULTS:
: 4
: 

Of course there is predefined function ~disvisors-count~, but it
is an example how to define custom function.

* Some multiplicative functions

** Mobius function - $\mu$.

Mobius function defined as:


$$ \mu(n) = \begin{cases}
1        &  \quad \text{if } n = 1 \\
(-1)^k   &  \quad \text{if } n \text{ product of distinct primes} \\
0        &  \quad \text{otherwise}
\end{cases} $$

For example, $\mu(6)=\mu(2 \cdot 3)=1$

#+begin_src clojure :exports both
  (nt/mobius 6)
#+end_src

#+RESULTS:
: 1


** Euler totient function - $\phi$

Euler totient function is a count of numbers relative prime to given number ~n~.
Totient function can be calculated by formula: 


$$ \phi(n) = \prod_{p|n} (p^a - p^{a-1}) $$

For example, count of numbers relative prime to $6$ are $1$ and $5$, so $\phi(6) = 2$

#+begin_src clojure :exports both
  (nt/totient 6)
#+end_src

#+RESULTS:
: 2

** Unit function - $\epsilon$

Unit function defined as

$$ \epsilon(n) = \begin{cases}
1,&  \text{if } n = 1 \\
0,&  \text{if } n > 1
\end{cases} $$

#+begin_src clojure :results pp :exports both
  (nt/unit 6)
#+end_src

#+RESULTS:
: 0
: 

** Constant one function - $1$

$$ 1(n) = 1 $$

#+begin_src clojure :results pp :exports both
  (nt/one 6)
#+end_src

#+RESULTS:
: 1
: 


** Divisors count - $\sigma_0$

Divisors count is number of divisors which divides given number $n$.

$$ \sigma_0(n) = \sum_{d|n} 1 $$

For example, number $64 has $4$ divisors, namely $1,2,3,6$, so $\sigma_0(6)=4$

#+begin_src clojure :results pp
(nt/divisors-count 6)
#+end_src

#+RESULTS:
: 4
: 

** Divisors sum - $\sigma_1$

$$ \sigma_1(n) = \sum_{d | n} d $$

For number 6 it is $12 = 1 + 2 + 3 + 6$

#+begin_src clojure :results pp :exports both
  (nt/divisors-sum 6)
#+end_src

#+RESULTS:
: 12
: 

** Divisors square sum

$$ \sigma_2(n) = \sum_{d | n} d^2 $$

For number 6 it is $50 = 1^2 + 2^2 + 3^2 + 6^2$

#+begin_src clojure :results pp :exports both
  (nt/divisors-square-sum 6)
#+end_src

#+RESULTS:
: 50
: 

** Divisor higher order function - $\sigma_{x}$

In general $\sigma_x$ function is a sum of x-th powers divisors of given n

$$ \sigma_x(n) = \sum_{ d | n} d^x $$

If $x \ne 0$ $\sigma_x$ can be calculated by formula:

$$ \sigma_{x}(n) = \prod_{i=1}^{k} \frac {p_i^{(a_i+1)x}} {p_i^x - 1} $$

and if $x = 0$ by formula:

$$ \sigma_{0}(n) = \prod_{i=1}^{k} (a_i + 1) $$

There is higher order function ~divisors-sum-x~ which
accept ~x~ and return appropriate function.

#+begin_src clojure :results silent
  (def my-divisors-square-sum (nt/divisors-sum-x 2))
#+end_src


* Dirichlet convolution

For two arithmetic functions $f$ and $g$ Dirichlet convolution is a
new arithmetic function defined as

$$ (f*g)(n) = \sum_{d | n} f(d)g(\frac{n}{d}) $$

Dirichlet convolution is associative

$$ (f * g) * h = f * (g * h) $$

Commutative

$$ f * g = g * f $$

Has identify

$$ f * \epsilon = \epsilon * f = f $$

For every $f$, which $f(1) \ne 0$ exists inverse function $f^{-1}$ such that $f * f^{-1} = \epsilon$. This
inverse function called Dirichlet inverse and can by calculated recursively by:

$$ f^{-1}(n) = \begin{cases}
\frac{1}{f(1)} & \quad \text{if } n = 1  \\
\frac{-1}{f(1)}\sum_{ \substack{d | n\\
                                d < n}} f(\frac{n}{d}) f^{-1}(d)
               & \quad n \ge 1
\end{cases} $$


For example, $1(n) * 1(n) = \sigma_0$

#+begin_src clojure :exports both :results pp
  (nt/f=
     (nt/f* nt/one nt/one)
     nt/divisors-count
  )
#+end_src

#+RESULTS:
: true
: 

Dirichlet convolution is associative so clojure method support more than two
function as parameter of ~f*~

#+begin_src clojure :exports both :results pp
  (nt/f=
    (nt/f* nt/mobius nt/one nt/mobius nt/one)
    nt/unit
  )
#+end_src

#+RESULTS:
: true
: 

Another example, functions $\mu(n)$ and $1(n)$ are inverse of each other

#+begin_src clojure :exports both :results value
    (nt/f= (nt/inverse nt/one) nt/mobius)
    (nt/f= (nt/inverse nt/mobius) nt/one)
#+end_src

#+RESULTS:
| class clojure.lang.Compiler$CompilerException |
| class clojure.lang.Compiler$CompilerException |


#+begin_src clojure :results value
  (nt/inverse nt/mobius)
#+end_src

#+RESULTS:
: class clojure.lang.Compiler$CompilerException
